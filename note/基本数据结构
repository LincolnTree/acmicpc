  栈实现了一种后进先出的策略。
      主要有push和pop两种操作。当试图对空栈作弹出操作，则称为栈下溢；对满栈进行压入操作，称为栈上溢。
  
  队列实现了先进先出的策略。队列有头和尾。
      主要有enqueue和dequeue两种操作。入队元素排在队尾，出队的元素总是队首元素。
      试图从空队列中删除一个元素，会导致队列下溢；试图向满队列中插入一个元素，会引起队列上溢。
      
  链表中各对象按线性顺序排序。数组的线性序是由数组下标决定的，而链表中的顺序是由各对象中的指针所决定的。
      双链表L的每个元素都是一个对象，每个对象包含一个关键字域和两个指针域：next和prev。如果pre[x]=NIL，则元素x没有前驱结点，它是链表的第一个元素；若
next[x]=NIL，则元素没有后继结点，它是链表的最后一个元素。属性head[L]指向表的第一个元素。如果head[L]=NIL，则该链表为空。
      链表的查询是线性查询，从表头开始找。链表的插入是插入为第一个元素。链表的插入删除都是O(1)的。
      添加一个空对象nil[L]做哨兵，简化边界条件，在表头表尾做删除时可以不再考虑边界问题。我们可以去掉属性head[L]，把对它的引用换成对next[nil[L]]的引用。
next[nil[L]]指向表头，prev[nil[L]]指向表尾，这样将一般的双向链表变成了带哨兵的环形双向链表。
      但如果有很多较短的链表，使用哨兵会造成存储的浪费。
      *分配和释放对象

  nil是一个对象值，如果要把一个对象设置为空的时候就用nil。
  Nil是一个类对象的值，如果要把一个Class类型的对象设置为空的时候就用Nil。
  NULL是一个通用指针。

  有根二叉树、分支数无限制的有根树
    有根二叉树结构包括指向根节点的指针root[T]，指向父节点的指针、左右孩子指针；
    当树无分支数限制时，继续保持指向每个孩子的指针会造成存储空间的浪费。此时每个节点除了指向父节点的指针外，仅包含两个指针：指向最左孩子的指针，
指向右边兄弟节点的指针。







相关资料：算法导论
